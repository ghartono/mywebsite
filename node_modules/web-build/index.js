#!/usr/bin/env node

const argparse = require('argparse')
const path     = require('path')
const fs       = require('fs')
const url      = require('url')
const http     = require('http')
const pkg      = require('./package.json')

function concatenateFiles (args) {
  let str = '';
  args.paths.forEach((path)=> {
    str += fs.readFileSync(path, 'utf8');
  });
  return str;
}

function serveBuild (res, args) {
  res.setHeader('Content-type', args.contentType)
  res.end(concatenateFiles(args))
}

function buildOnRequest (args) {
  const dirpath = args.static ? path.resolve(args.static) : ''
  return function onRequest (req, res) {
    if (args.verbose) console.log(`${req.method} ${req.url}`)
    const parsedUrl = url.parse(req.url)
    if (parsedUrl.pathname == '/') {
      serveBuild(res, args)
      return
    }
    if (!dirpath) {
      res.statusCode = 404
      res.end('No content found.')
      return
    }
    let pathname = `.${parsedUrl.pathname}`
    const ext = path.parse(pathname).ext;
    const map = {
      '.ico': 'image/x-icon',
      '.html': 'text/html',
      '.js': 'text/javascript',
      '.json': 'application/json',
      '.css': 'text/css',
      '.png': 'image/png',
      '.jpg': 'image/jpeg',
      '.wav': 'audio/wav',
      '.mp3': 'audio/mpeg',
      '.svg': 'image/svg+xml',
      '.pdf': 'application/pdf',
      '.doc': 'application/msword'
    }
    const filepath = path.join(dirpath, pathname)
    fs.stat(filepath, function (err, stat) {
      if (err) {
        if (args.buildOnMissing) {
          serveBuild(res, args)
        } else {
          res.statusCode = 404
          res.end(`File ${pathname} not found!`)
        }
        return
      }
      if (stat.isDirectory()) pathname += '/index' + ext
      fs.readFile(filepath, function(err, data){
        if (err) {
          res.statusCode = 500
          res.end(`Error getting the file: ${err}.`)
          return
        }
        res.setHeader('Content-type', map[ext] || 'text/plain')
        res.end(data);
      })
    })
  }
}

function startServer (args) {
  http.createServer(buildOnRequest(args)).listen(parseInt(args.port))
  if (args.verbose) console.log(`Listening on port ${args.port}.`)
}

const parser = new argparse.ArgumentParser({
  version: pkg.version,
  description: pkg.description,
  addHelp: true
})
parser.addArgument('paths', {
  help: 'File paths to build in order.',
  nargs: '+'
})
const sub = parser.addSubparsers({
  title: 'Command',
  dest: 'command'
})
const build = sub.addParser('build', {
  addHelp: true,
  description: 'Builds a static page.'
})
const serve = sub.addParser('serve', {
  addHelp: true,
  description: 'Serve using express by building the page on the request.'
})
serve.addArgument(['-s', '--static'], {
  help: 'Specify a static directory to serve.',
  dest: 'static',
  metavar: 'DIR'
})
serve.addArgument(['-c', '--content-type'], {
  help: 'Set the default content type of the built file.',
  dest: 'contentType',
  defaultValue: 'text/html'
})
serve.addArgument(['-m', '--build-on-missing'], {
  help: 'Serves the build contents if a file is not found.',
  dest: 'buildOnMissing',
  action: 'storeTrue'
})
serve.addArgument(['-v', '--verbose'], {
  help: 'Allows logging of the server interactions.',
  dest: 'verbose',
  action: 'storeTrue'
})
serve.addArgument(['-p', '--port'], {
  help: 'Specify port to run on.',
  defaultValue: 8080,
  dest: 'port',
  metavar: 8080
})

const args = parser.parseArgs();
switch (args.command) {
  case "build":
    process.stdout.write(concatenateFiles(args));
    break;
  case "serve":
    startServer(args);
    break;
}
